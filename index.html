<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GentleDoc - Editor de Documentos</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiR2VudGxlRG9jIiwic2hvcnRfbmFtZSI6IkdlbnRsZURvYyIsInN0YXJ0X3VybCI6Ii4vIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzBmMTcyYSIsInRoZW1lX2NvbG9yIjoiIzYzNjZmMSIsImljb25zIjpbeyJzcmMiOiJodHRwczovL2Nkbi1qdGVjaG9saW5lLmNvbS9maWxlcy9kb2N2aWV3ZXItaWNvbi5wbmciLCJzaXplcyI6IjE5MngxOTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIn1dfQ==" />

  <!-- Librerías Externas -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
  
  <!-- Fuentes -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <style>
    :root {
      /* Theme: Midnight Slate */
      --bg-app: #0f172a;
      --bg-panel: #1e293b;
      --bg-header: rgba(15, 23, 42, 0.95);
      --bg-hover: #334155;
      --bg-input: #020617;
      --bg-selection: #2563eb;
      
      --accent: #6366f1;
      --accent-hover: #4f46e5;
      
      --text-primary: #f8fafc;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      
      --border: #334155;
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      
      --radius-sm: 6px;
      --radius-md: 8px;
      
      --font-ui: "Inter", sans-serif;
      --font-code: 'JetBrains Mono', 'Courier New', monospace;
      
      --shadow-lg: 0 20px 25px -5px rgb(0 0 0 / 0.5);
    }

    /* Light Theme Variables */
    [data-theme="light"] {
      --bg-app: #f1f5f9;
      --bg-panel: #ffffff;
      --bg-header: rgba(255, 255, 255, 0.95);
      --bg-hover: #e2e8f0;
      --bg-input: #f8fafc;
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --border: #cbd5e1;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; outline: none; }
    
    body {
      font-family: var(--font-ui);
      background-color: var(--bg-app);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      line-height: 1.5;
    }

    /* Scrollbars */
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--bg-hover); border-radius: 5px; border: 2px solid var(--bg-app); }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    /* Layout */
    #app-shell { display: grid; grid-template-rows: 50px 1fr 28px; height: 100vh; }

    /* Header */
    header { background: var(--bg-header); backdrop-filter: blur(8px); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 16px; gap: 12px; z-index: 50; }
    header .brand { font-weight: 700; color: var(--text-primary); font-size: 16px; display: flex; gap: 8px; margin-right: 12px; }
    header button { background: transparent; border: 1px solid transparent; color: var(--text-secondary); padding: 6px 12px; border-radius: var(--radius-sm); cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 8px; transition: all 0.2s; }
    header button:hover { background: var(--bg-hover); color: var(--text-primary); }
    .divider { width: 1px; height: 20px; background: var(--border); margin: 0 4px; }

    /* Main Area & Tabs */
    main { display: grid; grid-template-rows: 36px 1fr; overflow: hidden; }
    .tab-bar { background: var(--bg-app); border-bottom: 1px solid var(--border); display: flex; align-items: flex-end; padding: 0 8px; gap: 4px; }
    .tabs-container { display: flex; gap: 4px; overflow-x: auto; flex: 1; scrollbar-width: none; }
    .tab { padding: 6px 10px; background: transparent; color: var(--text-secondary); border-radius: var(--radius-sm) var(--radius-sm) 0 0; font-size: 12px; min-width: 96px; max-width: 220px; cursor: pointer; border: 1px solid transparent; border-bottom: none; display: flex; align-items: center; gap: 6px; }
    .tab:hover { background: var(--bg-hover); }
    .tab.active { background: var(--bg-panel); color: var(--accent); border-color: var(--border); font-weight: 600; border-bottom-color: var(--bg-panel); }
    .tab-name { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .tab .close { margin-left: auto; opacity: 0.72; font-size: 14px; flex-shrink: 0; }
    .tab:hover .close, .tab.active .close { opacity: 1; }
    .tab .close:hover { color: var(--error); }

    /* Workspace */
    .workspace { display: grid; grid-template-columns: 240px 1fr; background: var(--bg-panel); height: 100%; overflow: hidden; }
    .sidebar { background: var(--bg-panel); border-right: 1px solid var(--border); padding: 10px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
    .sidebar h4 { color: var(--text-muted); font-size: 11px; text-transform: uppercase; margin-bottom: 8px; font-weight: 600; }
    .file-item { padding: 6px 8px; border-radius: var(--radius-sm); cursor: pointer; color: var(--text-secondary); font-size: 13px; display: flex; gap: 8px; align-items: center; }
    .file-item:hover { background: var(--bg-hover); color: var(--text-primary); }
    .file-item.active { color: var(--accent); background: rgba(99, 102, 241, 0.1); }

    /* Content */
    .content-region { position: relative; background: #111; overflow: hidden; display: flex; flex-direction: column; }
    [data-theme="light"] .content-region { background: #e2e8f0; }
    .content-scroll { width: 100%; height: 100%; overflow: auto; position: relative; }

    /* --- SPECIALIZED VIEWS CSS --- */
    
    /* IMPROVED OFFICE EDITOR LAYOUT */
    .office-editor-wrapper { display: flex; flex-direction: column; height: 100%; background: #e5e7eb; color: #000; }
    .ql-toolbar { border-color: #ccc !important; background: #f3f4f6; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    .ql-container { border: none !important; flex: 1; overflow-y: auto !important; display: flex; justify-content: center; padding: 40px 20px; }
    
    #print-container {
        background: white; 
        width: 210mm; 
        min-height: 297mm; 
        padding: 25mm;
        box-shadow: 0 4px 15px rgba(0,0,0,0.15); 
        margin-bottom: 40px;
        overflow-y: visible !important;
        height: auto !important;
        color: black;
    }
    
    .docx-viewer-container {
        background: #e5e7eb;
        padding: 40px;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100%;
        overflow: auto;
    }
    .docx-wrapper, .odt-wrapper {
        background: white;
        width: 210mm;
        min-height: 297mm;
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        padding: 25mm;
        margin-bottom: 20px;
        color: black;
        font-family: 'Times New Roman', serif;
        font-size: 12pt;
        line-height: 1.5;
        overflow-wrap: break-word;
    }
    
    .odt-wrapper p { margin-bottom: 1em; }
    .odt-wrapper h1 { font-size: 24pt; font-weight: bold; margin-top: 1em; margin-bottom: 0.5em; }
    .odt-wrapper h2 { font-size: 18pt; font-weight: bold; margin-top: 1em; margin-bottom: 0.5em; }
    .odt-wrapper h3 { font-size: 14pt; font-weight: bold; }
    .odt-wrapper img { max-width: 100%; height: auto; }
    .odt-wrapper table { width: 100%; border-collapse: collapse; margin: 1em 0; }
    .odt-wrapper td, .odt-wrapper th { border: 1px solid #000; padding: 5px; }

    /* Media View */
    .media-view { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; }
    .media-view img, .media-view video { max-width: 90%; max-height: 90%; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }

    .mini-editor-shell { width: min(960px, 100%); background: var(--bg-panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; display: flex; flex-direction: column; gap: 14px; }
    .mini-editor-toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .mini-editor-toolbar button { background: var(--bg-input); border: 1px solid var(--border); color: var(--text-primary); border-radius: var(--radius-sm); padding: 8px 12px; cursor: pointer; }
    .mini-editor-toolbar button:hover { border-color: var(--accent); color: var(--accent); }
    .mini-editor-toolbar label { font-size: 12px; color: var(--text-secondary); display: inline-flex; gap: 6px; align-items: center; }
    .mini-editor-toolbar input[type="range"] { accent-color: var(--accent); }
    .image-editor-canvas { align-self: center; max-width: 100%; max-height: 65vh; border-radius: 8px; border: 1px solid var(--border); background: #111827; }
    .audio-editor-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .audio-editor-grid .control-row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; color: var(--text-secondary); font-size: 13px; }
    .audio-editor-grid .control-row input[type="range"] { width: 180px; }
    .audio-editor-grid .trim-input { width: 88px; padding: 4px 6px; border-radius: var(--radius-sm); border: 1px solid var(--border); background: var(--bg-input); color: var(--text-primary); }
    .audio-editor-grid .trim-range { width: 220px; }
    .audio-editor-grid .note { color: var(--text-muted); font-size: 12px; }
    
    /* Split View */
    .split-view { display: flex; width: 100%; height: 100%; overflow: hidden; }
    .split-editor { width: 50%; height: 100%; overflow: hidden; flex-shrink: 0; }
    .split-preview { flex: 1; height: 100%; overflow: auto; background: var(--bg-panel); color: var(--text-primary); position: relative; padding: 30px; }
    [data-theme="light"] .split-preview { background: #fff; color: #333; }
    .split-resizer-handle { width: 8px; cursor: col-resize; background: var(--bg-app); border-left: 1px solid var(--border); border-right: 1px solid var(--border); flex-shrink: 0; z-index: 20; transition: background 0.2s; }
    .split-resizer-handle:hover, .split-resizer-handle.dragging { background: var(--accent); }

    /* Markdown Styling */
    .split-preview h1 { border-bottom: 1px solid var(--border); padding-bottom: 0.3em; }
    .split-preview code { background: rgba(127,127,127,0.15); padding: 2px 5px; border-radius: 4px; color: var(--accent); }
    .split-preview pre { background: #0f172a; padding: 15px; border-radius: 8px; overflow-x: auto; color: #e2e8f0; }
    .split-preview blockquote { border-left: 4px solid var(--accent); padding-left: 15px; color: var(--text-muted); }
    .split-preview table { width: 100%; border-collapse: collapse; }
    .split-preview th, .split-preview td { border: 1px solid var(--border); padding: 8px; text-align: left; }
    .split-preview img { max-width: 100%; border-radius: 6px; }

    /* Console */
    .console-panel { height: 150px; background: #000; color: #fff; font-family: var(--font-code); font-size: 12px; padding: 10px; overflow-y: auto; border-top: 1px solid var(--border); display: none; }
    .log-entry { margin-bottom: 4px; border-bottom: 1px solid #333; word-wrap: break-word; white-space: pre-wrap; }
    .log-error { color: var(--error); } .log-success { color: var(--success); } .log-warning { color: var(--warning); } .log-info { color: var(--accent); }

    /* PDF Tools */
    .pdf-text-input { position: absolute; background: rgba(255,255,255,0.9); color: black; border: 1px solid var(--accent); padding: 4px; font-family: sans-serif; font-size: 14px; min-width: 100px; z-index: 50; }
    .pdf-canvas-layer { pointer-events: none; position: absolute; top:0; left:0; z-index: 20; }
    .pdf-page-wrapper.draw-mode .pdf-canvas-layer { pointer-events: auto; cursor: crosshair; }
    
    /* Toolbar */
    .floating-toolbar { position: sticky; top: 20px; margin: 0 auto 20px auto; background: var(--bg-header); border: 1px solid var(--border); border-radius: 20px; padding: 5px 15px; display: flex; gap: 10px; z-index: 40; box-shadow: var(--shadow-lg); backdrop-filter: blur(5px); width: fit-content; }
    .floating-toolbar button { background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 5px; font-size: 14px; }
    .floating-toolbar button:hover, .floating-toolbar button.active { color: var(--accent); }

    /* Modals */
    .cmd-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; display: none; justify-content: center; align-items: flex-start; padding-top: 80px; backdrop-filter: blur(4px); }
    .cmd-palette { width: 600px; max-width: 90%; background: var(--bg-panel); border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); overflow: hidden; display: flex; flex-direction: column; max-height: 400px; }
    .cmd-input-wrapper { padding: 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
    #cmd-input { background: transparent; border: none; width: 100%; font-size: 18px; color: var(--text-primary); }
    .cmd-list { list-style: none; overflow-y: auto; padding: 8px 0; margin: 0; }
    .cmd-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; color: var(--text-secondary); transition: all 0.1s; }
    .cmd-item:hover, .cmd-item.selected { background: var(--bg-selection); color: white; }
    .cmd-item .shortcut { font-size: 11px; opacity: 0.7; border: 1px solid rgba(255,255,255,0.3); padding: 2px 6px; border-radius: 4px; }

    .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; display: none; justify-content: center; align-items: center; backdrop-filter: blur(2px); }
    .modal { width: 500px; max-width: 90%; background: var(--bg-panel); border: 1px solid var(--border); border-radius: 12px; box-shadow: var(--shadow-lg); overflow: hidden; display: flex; flex-direction: column; animation: slideUp 0.2s; }
    @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    .modal-header { padding: 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; font-weight: 600; }
    .modal-body { padding: 20px; overflow-y: auto; max-height: 60vh; }
    
    .draft-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    .draft-option { background: var(--bg-input); border: 1px solid var(--border); border-radius: 8px; padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; cursor: pointer; transition: all 0.2s; color: var(--text-primary); }
    .draft-option:hover { border-color: var(--accent); background: var(--bg-hover); transform: translateY(-2px); }
    .draft-option i { font-size: 24px; margin-bottom: 5px; }

    .zoom-float { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 5px 12px; border-radius: 20px; font-size: 12px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 200; }
    .zoom-float.visible { opacity: 1; }

    .shortcuts-container { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
    .shortcut-section h3 { margin-top: 0; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 5px; margin-bottom: 15px; font-size: 13px; text-transform: uppercase; letter-spacing: 1px; }
    .shortcut-row { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 13px; align-items: center; }
    .shortcut-desc { color: var(--text-secondary); }
    .shortcut-keys kbd { background: var(--bg-hover); border: 1px solid var(--border); border-radius: 4px; padding: 3px 8px; font-family: var(--font-code); font-size: 11px; color: var(--text-primary); box-shadow: 0 2px 0 var(--bg-app); margin-left: 4px; display: inline-block; }

    .hidden { display: none !important; }
    @media (max-width: 768px) { .workspace { grid-template-columns: 1fr; } .sidebar { display: none; } .shortcuts-container { grid-template-columns: 1fr; gap: 20px; } }
  </style>
</head>
<body>
  <div id="app-shell">
    <header>
      <div class="brand"><i class="fa-solid fa-file-lines"></i> GentleDoc</div>
      <div class="divider"></div>
      <button onclick="App.instance.openFileDialog()" title="Abrir archivo"><i class="fa-regular fa-folder-open"></i> Abrir</button>
      <button onclick="App.instance.saveCurrent()" title="Guardar cambios"><i class="fa-solid fa-floppy-disk"></i> Guardar</button>
      <button onclick="App.instance.promptExport()" title="Exportar documento"><i class="fa-solid fa-file-export"></i> Exportar</button>
      <div class="divider"></div>
      <button onclick="App.instance.createDraft()" title="Crear Nuevo Documento"><i class="fa-solid fa-plus"></i> Draft</button>
      <button onclick="UIManager.toggleCommandPalette()" title="Comandos"><i class="fa-solid fa-terminal"></i> Comandos</button>
      <div style="flex:1"></div>
      <button onclick="UIManager.showShortcutsHelp()" title="Atajos de Teclado"><i class="fa-solid fa-circle-question"></i></button>
      <button onclick="SettingsManager.open()" title="Configuración"><i class="fa-solid fa-gear"></i></button>
      <button onclick="App.instance.toggleTheme()"><i class="fa-solid fa-circle-half-stroke"></i></button>
      <span style="font-size:11px; color:var(--text-muted);">v3.4</span>
    </header>

    <main>
      <div class="tab-bar"><div class="tabs-container" id="tabs"></div></div>
      <div class="workspace">
        <aside class="sidebar" id="sidebar">
          <section><h4>Recientes</h4><div id="recent-list"></div></section>
          <section><h4>Explorador</h4><div id="open-list"></div></section>
        </aside>
        <section class="content-region" id="content-region">
          <div id="content-scroll" class="content-scroll"></div>
          <div id="welcome-msg" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color:var(--text-muted); flex-direction:column; padding:20px;">
            <i class="fa-solid fa-layer-group" style="font-size:64px; margin-bottom:20px; color:var(--accent);"></i>
            <h2 style="color:var(--text-primary);">GentleDoc</h2>
            <p style="margin-bottom:20px;">Tu editor de documentos rápido y local</p>
            <button onclick="App.instance.openFileDialog()" style="background:var(--accent); color:white; padding:10px 20px; border:none; border-radius:6px; cursor:pointer; font-weight:600; font-size:14px;"><i class="fa-solid fa-folder-open"></i> Abrir Archivos</button>
            <div class="welcome-recents" id="welcome-recents-list"></div>
          </div>
        </section>
      </div>
    </main>

    <!-- Modals -->
    <div class="cmd-backdrop" id="cmd-backdrop"><div class="cmd-palette"><div class="cmd-input-wrapper"><i class="fa-solid fa-magnifying-glass" style="color:var(--accent)"></i><input type="text" id="cmd-input" placeholder="Comando..." autocomplete="off"></div><ul class="cmd-list" id="cmd-list"></ul></div></div>
    <div class="modal-backdrop" id="generic-modal" style="display:none;"><div class="modal"><div class="modal-header"><span id="generic-modal-title">Título</span><button onclick="UIManager.closeModal()" style="border:none;background:none;color:var(--text-muted);cursor:pointer;"><i class="fa-solid fa-xmark"></i></button></div><div class="modal-body" id="generic-modal-body"></div></div></div>
    <div class="modal-backdrop" id="settings-modal" style="display:none;"><div class="modal"><div class="modal-header"><span>Configuración</span><button onclick="SettingsManager.close()" style="border:none;background:none;color:var(--text-muted);cursor:pointer;"><i class="fa-solid fa-xmark"></i></button></div><div class="modal-body"><div style="margin-bottom:20px;"><label style="display:block;margin-bottom:8px;font-size:12px;text-transform:uppercase;">Fuente</label><select onchange="SettingsManager.updateFont(this.value)" style="width:100%;padding:8px;background:var(--bg-input);color:white;border:1px solid var(--border);border-radius:6px;"><option value="'JetBrains Mono', monospace">JetBrains Mono</option><option value="'Fira Code', monospace">Fira Code</option></select></div><div style="margin-bottom:20px;"><label style="display:block;margin-bottom:8px;font-size:12px;text-transform:uppercase;">Tamaño</label><input type="range" min="10" max="24" value="14" oninput="SettingsManager.updateFontSize(this.value, 'editor')" style="width:100%;"></div><div style="margin-bottom:20px;"><label style="display:block;margin-bottom:8px;font-size:12px;text-transform:uppercase;">Endpoint Piston (opcional)</label><input id="runner-endpoint-input" type="text" placeholder="https://tu-piston.example/api/v2/execute" onblur="SettingsManager.updateRunnerEndpoint(this.value)" style="width:100%;padding:8px;background:var(--bg-input);color:white;border:1px solid var(--border);border-radius:6px;"><div style="font-size:12px;color:var(--text-muted);margin-top:6px;">La API pública de emkc.org ahora requiere whitelist. Configura aquí tu endpoint propio para compilar y ejecutar.</div></div><div style="margin-bottom:20px;"><label style="display:block;margin-bottom:8px;font-size:12px;text-transform:uppercase;">Endpoint Judge0 (opcional)</label><input id="judge0-endpoint-input" type="text" placeholder="https://ce.judge0.com" onblur="SettingsManager.updateJudge0Endpoint(this.value)" style="width:100%;padding:8px;background:var(--bg-input);color:white;border:1px solid var(--border);border-radius:6px;"><div style="font-size:12px;color:var(--text-muted);margin-top:6px;">Fallback gratuito para Python/Java (requiere que tu instancia permita CORS).</div></div><button onclick="SettingsManager.executePanic()" style="width:100%;padding:12px;background:rgba(239,68,68,0.1);color:var(--error);border:1px solid var(--error);border-radius:8px;cursor:pointer;">Restablecer</button></div></div></div>
    <div class="zoom-float" id="zoom-float">100%</div>

  <input type="file" id="file-input" class="hidden" multiple />

  <!-- Scripts -->
  <script type="module">
    const ignoreErrors = ['ResizeObserver loop', 'limit exceeded'];
    window.addEventListener('error', e => { if(ignoreErrors.some(err => e.message.includes(err))) { e.stopImmediatePropagation(); e.preventDefault(); } });

    const SW_CODE = `self.addEventListener('install',e=>e.waitUntil(self.skipWaiting()));self.addEventListener('activate',e=>e.waitUntil(self.clients.claim()));self.addEventListener('fetch',e=>{});`;
    const swBlob = new Blob([SW_CODE], {type: 'application/javascript'});
    const swUrl = URL.createObjectURL(swBlob);
    if('serviceWorker' in navigator) { navigator.serviceWorker.register(swUrl).catch(() => {}); }

    class PluginLoader {
      static sources = {
        pdfjs: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js',
        pdfjsWorker: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
        pdflib: 'https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js',
        monaco: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.0/min/vs/loader.min.js',
        marked: 'https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js',
        skulpt: 'https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt.min.js',
        skulptStd: 'https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt-stdlib.js',
        mammoth: 'https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js',
        xlsx: 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js',
        jszip: 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js',
        quill: 'https://cdn.quilljs.com/1.3.6/quill.js',
        html2pdf: 'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js',
        docxPreview: 'https://cdn.jsdelivr.net/npm/docx-preview@0.1.15/dist/docx-preview.min.js'
      };
      static loaded = new Set();
      static async load(names) {
        const toLoad = (Array.isArray(names) ? names : [names]).filter(n => !this.loaded.has(n));
        if(toLoad.length === 0) return;
        const savedDefine = window.define; if (savedDefine && savedDefine.amd) window.define = undefined;
        try {
            await Promise.all(toLoad.map(name => new Promise((resolve, reject) => {
                const s = document.createElement('script'); s.src = this.sources[name];
                s.onload = () => { this.loaded.add(name); resolve(); }; s.onerror = (e) => { console.error("Load failed:", name); reject(e); }; document.head.appendChild(s);
            })));
        } finally { if (savedDefine) window.define = savedDefine; }
      }
    }

    class FileSystem {
      static dbName = 'HackerEleganteDB_v3';
      static async init() { return new Promise(r => { const q = indexedDB.open(this.dbName, 1); q.onupgradeneeded = () => q.result.createObjectStore('files', {keyPath: 'id'}); q.onsuccess = () => r(q.result); }); }
      static async put(file) { const db = await this.init(); db.transaction('files', 'readwrite').objectStore('files').put(file); }
      static async getAll() { const db = await this.init(); return new Promise(r => { db.transaction('files', 'readonly').objectStore('files').getAll().onsuccess = e => r(e.target.result || []); }); }
      static async getFile(id) { const db = await this.init(); return new Promise(r => { const tx = db.transaction('files', 'readonly').objectStore('files').get(id); tx.onsuccess = () => r(tx.result); }); }
      static async clear() { const db = await this.init(); db.transaction('files', 'readwrite').objectStore('files').clear(); }
    }

    class SettingsManager {
        static open() { document.getElementById('settings-modal').style.display = 'flex'; }
        static close() { document.getElementById('settings-modal').style.display = 'none'; }
        static updateFont(f) { document.documentElement.style.setProperty('--font-code', f); localStorage.setItem('pref_font', f); }
        static updateFontSize(s, t) { document.documentElement.style.setProperty(t === 'ui' ? '--ui-font-size' : '--editor-font-size', s + 'px'); }
        static updateRunnerEndpoint(endpoint) {
            const cleanEndpoint = (endpoint || '').trim().replace(/\/+$/, '');
            if (cleanEndpoint) {
                localStorage.setItem('runner_endpoint', cleanEndpoint);
            } else {
                localStorage.removeItem('runner_endpoint');
            }
        }
        static updateJudge0Endpoint(endpoint) {
            const cleanEndpoint = (endpoint || '').trim().replace(/\/+$/, '');
            if (cleanEndpoint) {
                localStorage.setItem('judge0_endpoint', cleanEndpoint);
            } else {
                localStorage.removeItem('judge0_endpoint');
            }
        }
        static async executePanic() { await FileSystem.clear(); localStorage.clear(); location.reload(); }
        static loadDefaults() {
            const f = localStorage.getItem('pref_font');
            if (f) document.documentElement.style.setProperty('--font-code', f);
            const endpointInput = document.getElementById('runner-endpoint-input');
            if (endpointInput) endpointInput.value = localStorage.getItem('runner_endpoint') || '';
            const judge0Input = document.getElementById('judge0-endpoint-input');
            if (judge0Input) judge0Input.value = localStorage.getItem('judge0_endpoint') || '';
        }
    }

    class CompilerService {
        static defaultJudge0Endpoint = 'https://ce.judge0.com';

        static async executeViaJudge0(language, code, baseEndpoint) {
            const endpoint = (baseEndpoint || '').trim().replace(/\/+$/, '');
            if (!endpoint) throw new Error('Endpoint Judge0 no configurado');

            const langToId = { py: 71, python: 71, java: 62 };
            const languageId = langToId[language];
            if (!languageId) {
                throw new Error('Judge0 fallback solo soporta Python y Java en esta versión.');
            }

            const payload = { source_code: code, language_id: languageId, stdin: '' };
            const submit = await fetch(`${endpoint}/submissions?base64_encoded=false&wait=true`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const raw = await submit.text();
            let data = null;
            try { data = raw ? JSON.parse(raw) : null; } catch (_) { data = null; }

            if (!submit.ok) {
                const detail = data?.message || data?.error || data?.detail || raw || 'sin detalles';
                return { stdout: '', stderr: `Error Judge0 (${submit.status}) en ${endpoint}: ${detail}`, code: 1 };
            }

            const decode = (value) => value || '';
            const stdout = decode(data?.stdout);
            const stderr = decode(data?.stderr);
            const compile = decode(data?.compile_output);
            const statusId = data?.status?.id;
            const codeOut = statusId === 3 ? 0 : 1;
            return {
                stdout,
                stderr: [compile, stderr].filter(Boolean).join(''),
                code: codeOut
            };
        }

        static async execute(language, code) {
            const langMap = { 'java': 'java', 'py': 'python', 'cpp': 'cpp', 'js': 'javascript', 'c': 'c', 'go': 'go', 'cs': 'csharp', 'php': 'php', 'rs': 'rust' };
            const lang = langMap[language] || language;
            const fileNameByLang = { java: 'Main.java', cpp: 'main.cpp', c: 'main.c', python: 'main.py' };
            const payload = {
                language: lang,
                version: '*',
                files: [{
                    name: fileNameByLang[lang],
                    content: code
                }]
            };
            const customEndpoint = (localStorage.getItem('runner_endpoint') || '').trim().replace(/\/+$/, '');
            const judge0Endpoint = (localStorage.getItem('judge0_endpoint') || '').trim().replace(/\/+$/, '');
            const resolvedJudge0Endpoint = judge0Endpoint || this.defaultJudge0Endpoint;
            const endpointVariants = [
                ...(customEndpoint ? [customEndpoint] : []),
                'https://emkc.org/api/v2/piston/execute',
                'https://emkc.org/api/v2/execute'
            ];

            const hintByStatus = (status) => {
                if (status === 526) {
                    return ' El proveedor remoto reporta un certificado SSL inválido (526).';
                }
                if (status === 429) {
                    return ' El servicio está limitado por rate limit (429); intenta de nuevo en unos segundos.';
                }
                if (status === 401) {
                    return ' El endpoint rechazó la solicitud (401). Si usas emkc.org, desde 2026 requiere whitelist; configura una instancia propia de Piston en Ajustes.';
                }
                if (status >= 500) {
                    return ' El proveedor remoto devolvió un error temporal del servidor.';
                }
                return '';
            };

            const buildApiError = (status, body, endpoint) => ({
                stdout: '',
                stderr: `Error de API (${status}) en ${endpoint}: ${body || 'sin detalles'}.${hintByStatus(status)}`,
                code: 1,
                requiresRunnerSetup: status === 401 && endpoint.includes('emkc.org') && !customEndpoint && !['py', 'java'].includes(language)
            });

            const parseJsonSafe = (raw) => {
                try { return raw ? JSON.parse(raw) : null; } catch (_) { return null; }
            };

            const executeAgainstEndpoint = async (endpoint) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000);
                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        mode: 'cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    const raw = await response.text();
                    const data = parseJsonSafe(raw);
                    return { ok: response.ok, status: response.status, data, raw, endpoint };
                } finally {
                    clearTimeout(timeoutId);
                }
            };

            try {
                let lastApiError = null;
                let lastNetworkError = null;

                for (const endpoint of endpointVariants) {
                    try {
                        const result = await executeAgainstEndpoint(endpoint);

                        if (!result.ok) {
                            const detail = result.data?.message || result.data?.error || result.data?.detail || result.raw;
                            lastApiError = buildApiError(result.status, detail, endpoint);
                            continue;
                        }

                        if (result.data?.run || result.data?.compile) {
                            return {
                                stdout: [result.data?.compile?.stdout, result.data?.run?.stdout].filter(Boolean).join(''),
                                stderr: [result.data?.compile?.stderr, result.data?.run?.stderr].filter(Boolean).join(''),
                                code: result.data?.run?.code ?? result.data?.compile?.code ?? 0
                            };
                        }

                        const detail = result.data?.message || result.data?.error || result.data?.detail || result.raw;
                        if (detail) {
                            lastApiError = { stdout: '', stderr: `Error de API en ${endpoint}: ${detail}`, code: 1 };
                        }
                    } catch (error) {
                        lastNetworkError = error;
                    }
                }

                const canUseJudge0 = ['py', 'java'].includes(language);
                if (resolvedJudge0Endpoint && canUseJudge0) {
                    try {
                        return await this.executeViaJudge0(language, code, resolvedJudge0Endpoint);
                    } catch (judgeErr) {
                        const extra = judgeErr?.message ? ` Fallback Judge0 falló: ${judgeErr.message}` : '';
                        if (lastApiError) {
                            lastApiError.stderr += extra;
                            return lastApiError;
                        }
                        return { stdout: '', stderr: `Error Judge0: ${judgeErr.message}`, code: 1 };
                    }
                }

                if (lastApiError) return lastApiError;
                if (lastNetworkError) {
                    return {
                        stdout: '',
                        stderr: 'Error de conexión: ' + lastNetworkError.message + '. Revisa conectividad o bloqueo CORS/firewall para las APIs externas.',
                        code: 1
                    };
                }

                return { stdout: '', stderr: 'Error desconocido en la API', code: 1 };
            } catch (e) {
                return { stdout: '', stderr: 'Error de conexión: ' + e.message, code: 1 };
            }
        }
    }

    class EditorFactory {
        static mapLang(ext) {
            const map = { 
                js:'javascript', py:'python', md:'markdown', html:'html', css:'css', json:'json', java:'java', cpp:'cpp', c:'c', h:'c',
                xml:'xml', sql:'sql', php:'php', go:'go', rs:'rust', cs:'csharp', sh:'shell', bat:'bat', ps1:'powershell',
                yaml:'yaml', yml:'yaml', ini:'ini', ts:'typescript' 
            };
            return map[ext] || 'plaintext';
        }

        static async loadMonaco() {
            if (window.monaco) return window.monaco;
            await PluginLoader.load('monaco'); await document.fonts.ready;
            return new Promise((resolve, reject) => {
                require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.0/min/vs' }});
                window.MonacoEnvironment = { getWorker: (w, l) => {
                    const src = `self.MonacoEnvironment = { baseUrl: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.0/min/' };importScripts('https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.0/min/vs/base/worker/workerMain.js');`;
                    return new Worker(URL.createObjectURL(new Blob([src], { type: 'application/javascript' })));
                }};
                require(['vs/editor/editor.main'], () => resolve(window.monaco), reject);
            });
        }

        static async createViewer(file) {
            // Priority: if has edited content (contentRef), use corresponding editor
            const ext = file.name.split('.').pop().toLowerCase();
            
            // Text based files always use contentRef if available
            if(['md', 'markdown'].includes(ext)) return this.createMarkdownView(file);
            if(['html'].includes(ext)) return this.createHtmlView(file);
            
            const codeExts = ['js','css','py','json','txt','java','cpp','c','h','xml','sql','php','go','rs','cs','sh','bat','ps1','yaml','yml','ini','ts','kt','swift','r','rb'];
            if(codeExts.includes(ext)) return this.createCodeView(file, ext);
            
            // Binary files logic: if contentRef exists, we are in "Edit Mode" state
            if(file.contentRef && (ext === 'docx' || ext === 'odt')) return this.createOfficeEditor(file, ext);

            // Default readers
            if(ext === 'docx') return this.createDocxViewer(file);
            if(ext === 'odt') return this.createOdtViewer(file); 
            if(['xlsx', 'csv'].includes(ext)) return this.createXlsxView(file);
            if(['pdf'].includes(ext)) return this.createPdfView(file);
            
            // Media
            const imgExts = ['png','jpg','jpeg','gif','svg','webp','bmp','ico'];
            if(imgExts.includes(ext)) return this.createImageView(file);
            const mediaExts = ['mp3','wav','mp4','webm','ogg'];
            if(mediaExts.includes(ext)) return this.createMediaView(file, ext);
            
            return this.createHexView(file);
        }

        static async createDocxViewer(file) {
            await PluginLoader.load('docxPreview');
            const container = document.createElement('div');
            container.className = 'docx-viewer-container';
            const toolbar = document.createElement('div');
            toolbar.className = 'floating-toolbar';
            toolbar.innerHTML = `<button id="enable-edit" title="Habilitar Edición"><i class="fa-solid fa-pen-to-square"></i> Editar</button>`;
            const docWrapper = document.createElement('div');
            docWrapper.className = 'docx-wrapper';
            docWrapper.id = 'print-container'; // Use this for PDF export
            container.appendChild(toolbar);
            container.appendChild(docWrapper);
            try {
                const buff = await file.blob.arrayBuffer();
                await window.docx.renderAsync(buff, docWrapper);
            } catch(e) { docWrapper.innerHTML = `<p style="color:red;padding:20px;">Error: ${e.message}</p>`; }
            toolbar.querySelector('#enable-edit').onclick = async () => {
                const editor = await this.createOfficeEditor(file, 'docx');
                container.parentElement.innerHTML = '';
                document.getElementById('content-scroll').appendChild(editor);
            };
            return container;
        }

        // --- ODT High-Fidelity Viewer ---
        static async createOdtViewer(file) {
            await PluginLoader.load('jszip');
            const container = document.createElement('div');
            container.className = 'docx-viewer-container';
            
            const toolbar = document.createElement('div');
            toolbar.className = 'floating-toolbar';
            toolbar.innerHTML = `<button id="enable-edit" title="Habilitar Edición"><i class="fa-solid fa-pen-to-square"></i> Editar</button>`;
            
            const docWrapper = document.createElement('div');
            docWrapper.className = 'odt-wrapper';
            docWrapper.id = 'print-container';
            
            container.appendChild(toolbar);
            container.appendChild(docWrapper);

            try {
                const zip = await JSZip.loadAsync(file.blob);
                const xml = await zip.file("content.xml").async("string");
                const parser = new DOMParser();
                const doc = parser.parseFromString(xml, "text/xml");
                
                // Helper to load image
                const loadImage = async (path) => {
                    try { const imgBlob = await zip.file(path).async("blob"); return URL.createObjectURL(imgBlob); } catch(e) { return null; }
                };

                const body = doc.getElementsByTagName("office:text")[0];
                
                // Recursive transformer
                const transform = async (node) => {
                    let html = '';
                    for (const child of Array.from(node.childNodes)) {
                        if (child.nodeType === 3) { // Text
                            html += child.textContent;
                        } else if (child.nodeName === 'text:p') {
                             html += `<p>${await transform(child)}</p>`;
                        } else if (child.nodeName === 'text:h') {
                             const level = child.getAttribute('text:outline-level') || 1;
                             html += `<h${level}>${await transform(child)}</h${level}>`;
                        } else if (child.nodeName === 'text:list') {
                             html += `<ul>${await transform(child)}</ul>`;
                        } else if (child.nodeName === 'text:list-item') {
                             html += `<li>${await transform(child)}</li>`;
                        } else if (child.nodeName === 'text:span') {
                             // Basic style heuristic
                             const styleName = child.getAttribute('text:style-name');
                             let style = '';
                             if(styleName && styleName.includes('Bold')) style += 'font-weight:bold;';
                             html += `<span style="${style}">${await transform(child)}</span>`;
                        } else if (child.nodeName === 'draw:frame') {
                             // Image handling
                             const imgNode = child.getElementsByTagName('draw:image')[0];
                             if(imgNode) {
                                 const href = imgNode.getAttribute('xlink:href');
                                 let path = href;
                                 if(!zip.file(path) && zip.file("Pictures/" + path)) path = "Pictures/" + path;
                                 
                                 const src = await loadImage(path);
                                 if(src) html += `<img src="${src}" style="max-width:100%"/>`;
                             }
                        } else if (child.nodeName === 'table:table') {
                             html += `<table border="1" style="width:100%; border-collapse:collapse;">${await transform(child)}</table>`;
                        } else if (child.nodeName === 'table:table-row') {
                             html += `<tr>${await transform(child)}</tr>`;
                        } else if (child.nodeName === 'table:table-cell') {
                             html += `<td style="padding:5px; border:1px solid #000;">${await transform(child)}</td>`;
                        } else {
                             html += await transform(child);
                        }
                    }
                    return html;
                };
                
                docWrapper.innerHTML = await transform(body);
                
            } catch(e) {
                docWrapper.innerHTML = `<p style="color:red">Error ODT: ${e.message}</p>`;
            }

            toolbar.querySelector('#enable-edit').onclick = async () => {
                const editor = await this.createOfficeEditor(file, 'odt');
                container.parentElement.innerHTML = '';
                document.getElementById('content-scroll').appendChild(editor);
            };

            return container;
        }

        static async createOfficeEditor(file, ext) {
            await PluginLoader.load('quill');
            const wrapper = document.createElement('div');
            wrapper.className = 'office-editor-wrapper';
            const toolbarContainer = document.createElement('div');
            const editorContainer = document.createElement('div');
            editorContainer.id = 'print-container'; 
            wrapper.appendChild(toolbarContainer);
            wrapper.appendChild(editorContainer);
            
            let initialHtml = '';
            
            // Check contentRef first!
            if (file.contentRef) {
                initialHtml = file.contentRef;
            } else {
                if (ext === 'docx') {
                    await PluginLoader.load('mammoth');
                    try {
                        const buff = await file.blob.arrayBuffer();
                        const res = await mammoth.convertToHtml({arrayBuffer: buff});
                        initialHtml = res.value;
                    } catch(e) { initialHtml = `<p style="color:red">Error: ${e.message}</p>`; }
                } else if (ext === 'odt') {
                    await PluginLoader.load('jszip');
                    try {
                        const zip = await JSZip.loadAsync(file.blob);
                        const xml = await zip.file("content.xml").async("string");
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(xml, "text/xml");
                        const body = doc.getElementsByTagName("office:text")[0];
                        
                        // Copy image helper logic for Editor
                        const loadImage = async (path) => {
                             try { const imgBlob = await zip.file(path).async("blob"); return URL.createObjectURL(imgBlob); } catch(e) { return null; }
                        };
                        const transform = async (node) => {
                            let html = '';
                            for (const child of Array.from(node.childNodes)) {
                                if (child.nodeType === 3) html += child.textContent;
                                else if (child.nodeName === 'text:p') html += `<p>${await transform(child)}</p>`;
                                else if (child.nodeName === 'text:h') html += `<h${child.getAttribute('text:outline-level')||1}>${await transform(child)}</h${child.getAttribute('text:outline-level')||1}>`;
                                else if (child.nodeName === 'text:span') html += `<span>${await transform(child)}</span>`; 
                                else if (child.nodeName === 'draw:frame') {
                                     const imgNode = child.getElementsByTagName('draw:image')[0];
                                     if(imgNode) {
                                         let path = imgNode.getAttribute('xlink:href');
                                         if(!zip.file(path) && zip.file("Pictures/" + path)) path = "Pictures/" + path;
                                         const src = await loadImage(path);
                                         if(src) html += `<img src="${src}"/>`;
                                     }
                                }
                                else if (child.nodeName === 'table:table') html += `<table border="1" style="width:100%; border-collapse:collapse;">${await transform(child)}</table>`;
                                else if (child.nodeName === 'table:table-row') html += `<tr>${await transform(child)}</tr>`;
                                else if (child.nodeName === 'table:table-cell') html += `<td style="padding:5px; border:1px solid #ccc;">${await transform(child)}</td>`;
                                else html += await transform(child);
                            }
                            return html;
                        };
                        initialHtml = await transform(body);

                    } catch(e) { initialHtml = `<p style="color:red">Error leyendo ODT para edición: ${e.message}</p>`; }
                }
            }

            const quill = new Quill(editorContainer, {
                theme: 'snow',
                placeholder: 'Escribe aquí...',
                modules: {
                    toolbar: [
                        [{ 'header': [1, 2, 3, false] }],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'color': [] }, { 'background': [] }],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        [{ 'align': [] }],
                        ['link', 'image'],
                        ['clean']
                    ]
                }
            });

            quill.clipboard.dangerouslyPasteHTML(initialHtml);
            quill.on('text-change', () => { file.isDirty = true; file.contentRef = quill.root.innerHTML; App.instance.renderTabs(); });
            
            return wrapper;
        }

        static async createXlsxView(file) {
            await PluginLoader.load('xlsx');
            const container = document.createElement('div');
            container.className = 'office-view';
            try {
                const arrayBuffer = await file.blob.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, {type: 'array'});
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const html = XLSX.utils.sheet_to_html(firstSheet);
                container.innerHTML = html;
            } catch(e) {
                container.innerHTML = `<p style="color:red">Error: ${e.message}</p>`;
            }
            return container;
        }

        static async createImageView(file) {
            const container = document.createElement('div');
            container.className = 'media-view';

            const shell = document.createElement('div');
            shell.className = 'mini-editor-shell';

            const toolbar = document.createElement('div');
            toolbar.className = 'mini-editor-toolbar';
            toolbar.innerHTML = `
                <button data-action="rotate-left"><i class="fa-solid fa-rotate-left"></i> -90°</button>
                <button data-action="rotate-right"><i class="fa-solid fa-rotate-right"></i> +90°</button>
                <button data-action="flip-x"><i class="fa-solid fa-left-right"></i> Voltear H</button>
                <button data-action="flip-y"><i class="fa-solid fa-up-down"></i> Voltear V</button>
                <button data-action="crop-toggle"><i class="fa-solid fa-crop-simple"></i> Modo recorte</button>
                <button data-action="crop-apply"><i class="fa-solid fa-check"></i> Aplicar recorte</button>
                <label>Brillo <input type="range" min="40" max="170" value="100" step="5" data-filter="brightness"></label>
                <label>Contraste <input type="range" min="40" max="180" value="100" step="5" data-filter="contrast"></label>
                <button data-action="reset"><i class="fa-solid fa-arrows-rotate"></i> Reset</button>
                <button data-action="download"><i class="fa-solid fa-download"></i> Descargar</button>
            `;

            const canvas = document.createElement('canvas');
            canvas.className = 'image-editor-canvas';
            const ctx = canvas.getContext('2d');

            const state = { rotation: 0, flipX: 1, flipY: 1, brightness: 100, contrast: 100 };
            const objectUrl = URL.createObjectURL(file.blob);
            const image = new Image();
            let imageSource = null;
            let cropMode = false;
            let dragStart = null;
            let cropRect = null;

            const syncCropButton = () => {
                const cropBtn = toolbar.querySelector('[data-action="crop-toggle"]');
                if (cropBtn) cropBtn.classList.toggle('active', cropMode);
            };

            const draw = () => {
                if (!imageSource || !imageSource.width || !imageSource.height) return;
                const rightAngle = Math.abs(state.rotation % 180) === 90;
                canvas.width = rightAngle ? imageSource.height : imageSource.width;
                canvas.height = rightAngle ? imageSource.width : imageSource.height;

                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.filter = `brightness(${state.brightness}%) contrast(${state.contrast}%)`;
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate((state.rotation * Math.PI) / 180);
                ctx.scale(state.flipX, state.flipY);
                ctx.drawImage(imageSource, -imageSource.width / 2, -imageSource.height / 2);
                ctx.restore();

                if (cropMode && cropRect) {
                    const { x, y, width, height } = cropRect;
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.clearRect(x, y, width, height);
                    ctx.strokeStyle = '#6366f1';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.strokeRect(x, y, width, height);
                    ctx.restore();
                }
            };

            const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

            image.onload = () => {
                imageSource = image;
                draw();
                URL.revokeObjectURL(objectUrl);
            };
            image.src = objectUrl;

            canvas.addEventListener('pointerdown', (event) => {
                if (!cropMode) return;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = clamp((event.clientX - rect.left) * scaleX, 0, canvas.width);
                const y = clamp((event.clientY - rect.top) * scaleY, 0, canvas.height);
                dragStart = { x, y };
                cropRect = { x, y, width: 1, height: 1 };
                canvas.setPointerCapture(event.pointerId);
                draw();
            });

            canvas.addEventListener('pointermove', (event) => {
                if (!cropMode || !dragStart) return;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const currentX = clamp((event.clientX - rect.left) * scaleX, 0, canvas.width);
                const currentY = clamp((event.clientY - rect.top) * scaleY, 0, canvas.height);
                const x = Math.min(dragStart.x, currentX);
                const y = Math.min(dragStart.y, currentY);
                cropRect = {
                    x,
                    y,
                    width: Math.max(1, Math.abs(currentX - dragStart.x)),
                    height: Math.max(1, Math.abs(currentY - dragStart.y))
                };
                draw();
            });

            const releaseCropDrag = () => { dragStart = null; };
            canvas.addEventListener('pointerup', releaseCropDrag);
            canvas.addEventListener('pointercancel', releaseCropDrag);

            toolbar.addEventListener('click', (event) => {
                const btn = event.target.closest('button[data-action]');
                if (!btn) return;
                const action = btn.dataset.action;
                if (action === 'rotate-left') state.rotation = (state.rotation - 90 + 360) % 360;
                if (action === 'rotate-right') state.rotation = (state.rotation + 90) % 360;
                if (action === 'flip-x') state.flipX *= -1;
                if (action === 'flip-y') state.flipY *= -1;
                if (action === 'crop-toggle') {
                    cropMode = !cropMode;
                    if (!cropMode) cropRect = null;
                    syncCropButton();
                }
                if (action === 'crop-apply') {
                    if (!cropRect || cropRect.width < 2 || cropRect.height < 2) {
                        UIManager.showToast('Selecciona una zona para recortar', true);
                    } else {
                        const tmp = document.createElement('canvas');
                        tmp.width = Math.floor(cropRect.width);
                        tmp.height = Math.floor(cropRect.height);
                        const tmpCtx = tmp.getContext('2d');
                        tmpCtx.drawImage(canvas, cropRect.x, cropRect.y, cropRect.width, cropRect.height, 0, 0, tmp.width, tmp.height);
                        const cropped = new Image();
                        cropped.onload = () => {
                            imageSource = cropped;
                            state.rotation = 0;
                            state.flipX = 1;
                            state.flipY = 1;
                            cropRect = null;
                            cropMode = false;
                            syncCropButton();
                            draw();
                            UIManager.showToast('Recorte aplicado');
                        };
                        cropped.src = tmp.toDataURL('image/png');
                    }
                }
                if (action === 'reset') {
                    state.rotation = 0;
                    state.flipX = 1;
                    state.flipY = 1;
                    state.brightness = 100;
                    state.contrast = 100;
                    cropMode = false;
                    cropRect = null;
                    imageSource = image;
                    syncCropButton();
                    toolbar.querySelector('[data-filter="brightness"]').value = '100';
                    toolbar.querySelector('[data-filter="contrast"]').value = '100';
                }
                if (action === 'download') {
                    const a = document.createElement('a');
                    a.href = canvas.toDataURL('image/png');
                    a.download = `edited_${file.name.replace(/\.[^.]+$/, '')}.png`;
                    a.click();
                }
                draw();
            });

            toolbar.querySelectorAll('input[data-filter]').forEach(input => {
                input.addEventListener('input', () => {
                    state[input.dataset.filter] = Number(input.value);
                    draw();
                });
            });

            shell.append(toolbar, canvas);
            container.appendChild(shell);
            return container;
        }

        static async createMediaView(file, ext) {
            const mediaType = ['mp4','webm','ogg'].includes(ext) ? 'video' : 'audio';
            if (mediaType === 'video') {
                const container = document.createElement('div');
                container.className = 'media-view';
                const video = document.createElement('video');
                video.src = URL.createObjectURL(file.blob);
                video.controls = true;
                container.appendChild(video);
                return container;
            }

            const container = document.createElement('div');
            container.className = 'media-view';

            const shell = document.createElement('div');
            shell.className = 'mini-editor-shell audio-editor-grid';

            const player = document.createElement('audio');
            player.src = URL.createObjectURL(file.blob);
            player.controls = true;

            const controls = document.createElement('div');
            controls.className = 'control-row';
            controls.innerHTML = `
                <label>Volumen <input type="range" min="0" max="1.6" step="0.05" value="1" data-audio="gain"></label>
                <label>Velocidad <input type="range" min="0.6" max="1.8" step="0.05" value="1" data-audio="rate"></label>
                <label>Tono <input type="range" min="-1200" max="1200" step="100" value="0" data-audio="detune"></label>
            `;

            const trimControls = document.createElement('div');
            trimControls.className = 'control-row';
            trimControls.innerHTML = `
                <label>Inicio (s) <input type="number" class="trim-input" value="0" min="0" step="0.1" data-audio-trim="start"></label>
                <label>Fin (s) <input type="number" class="trim-input" value="0" min="0" step="0.1" data-audio-trim="end"></label>
                <label class="trim-range-label">Rango <input type="range" min="0" max="100" step="1" value="0" class="trim-range" data-audio-trim="start-range"></label>
                <label class="trim-range-label">a <input type="range" min="0" max="100" step="1" value="100" class="trim-range" data-audio-trim="end-range"></label>
            `;

            const actions = document.createElement('div');
            actions.className = 'mini-editor-toolbar';
            actions.innerHTML = `
                <button data-audio-action="enable"><i class="fa-solid fa-wave-square"></i> Activar efectos</button>
                <button data-audio-action="preview-trim"><i class="fa-solid fa-scissors"></i> Previsualizar trozo</button>
                <button data-audio-action="cut-out"><i class="fa-solid fa-trash-can"></i> Quitar trozo</button>
                <button data-audio-action="keep-only"><i class="fa-solid fa-object-group"></i> Dejar solo trozo</button>
                <button data-audio-action="download"><i class="fa-solid fa-download"></i> Descargar copia</button>
                <span class="note">Editor básico: volumen/tono y recorte por rango (WAV).</span>
            `;

            let audioCtx = null;
            let sourceNode = null;
            let gainNode = null;
            let baseRate = 1;
            let detuneCents = 0;
            let workingBlob = file.blob;
            let trimLoop = null;

            const trimStartInput = trimControls.querySelector('[data-audio-trim="start"]');
            const trimEndInput = trimControls.querySelector('[data-audio-trim="end"]');
            const trimStartRange = trimControls.querySelector('[data-audio-trim="start-range"]');
            const trimEndRange = trimControls.querySelector('[data-audio-trim="end-range"]');

            const setPlayerBlob = (blob) => {
                const oldSrc = player.src;
                player.pause();
                player.src = URL.createObjectURL(blob);
                player.load();
                setTimeout(() => {
                    if (oldSrc.startsWith('blob:')) URL.revokeObjectURL(oldSrc);
                }, 2000);
            };

            const ensureAudioGraph = () => {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (!gainNode) {
                    gainNode = audioCtx.createGain();
                    gainNode.connect(audioCtx.destination);
                }
                if (!sourceNode) {
                    sourceNode = audioCtx.createMediaElementSource(player);
                    sourceNode.connect(gainNode);
                }
            };

            const syncTrimFromDuration = () => {
                const duration = Number.isFinite(player.duration) ? player.duration : 0;
                if (!duration || duration <= 0) return;
                trimStartInput.max = duration.toFixed(2);
                trimEndInput.max = duration.toFixed(2);
                if (Number(trimEndInput.value) === 0) trimEndInput.value = duration.toFixed(2);
                trimStartRange.value = Math.round((Number(trimStartInput.value) / duration) * 100);
                trimEndRange.value = Math.round((Number(trimEndInput.value) / duration) * 100);
            };

            const normalizeTrimValues = () => {
                const duration = Number.isFinite(player.duration) ? player.duration : 0;
                if (!duration || duration <= 0) return { start: 0, end: 0, duration: 0 };
                let start = Math.max(0, Math.min(Number(trimStartInput.value) || 0, duration));
                let end = Math.max(0, Math.min(Number(trimEndInput.value) || duration, duration));
                if (end <= start) end = Math.min(duration, start + 0.1);
                trimStartInput.value = start.toFixed(2);
                trimEndInput.value = end.toFixed(2);
                trimStartRange.value = Math.round((start / duration) * 100);
                trimEndRange.value = Math.round((end / duration) * 100);
                return { start, end, duration };
            };

            const readBlobAsArrayBuffer = (blob) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error || new Error('Error leyendo audio'));
                reader.readAsArrayBuffer(blob);
            });

            const encodeWav = (audioBuffer) => {
                const numberOfChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const bytesPerSample = 2;
                const blockAlign = numberOfChannels * bytesPerSample;
                const dataLength = audioBuffer.length * blockAlign;
                const buffer = new ArrayBuffer(44 + dataLength);
                const view = new DataView(buffer);
                let offset = 0;
                const writeString = (str) => {
                    for (let i = 0; i < str.length; i++) view.setUint8(offset++, str.charCodeAt(i));
                };

                writeString('RIFF');
                view.setUint32(offset, 36 + dataLength, true); offset += 4;
                writeString('WAVE');
                writeString('fmt ');
                view.setUint32(offset, 16, true); offset += 4;
                view.setUint16(offset, 1, true); offset += 2;
                view.setUint16(offset, numberOfChannels, true); offset += 2;
                view.setUint32(offset, sampleRate, true); offset += 4;
                view.setUint32(offset, sampleRate * blockAlign, true); offset += 4;
                view.setUint16(offset, blockAlign, true); offset += 2;
                view.setUint16(offset, bytesPerSample * 8, true); offset += 2;
                writeString('data');
                view.setUint32(offset, dataLength, true); offset += 4;

                const channels = [];
                for (let c = 0; c < numberOfChannels; c++) channels.push(audioBuffer.getChannelData(c));

                for (let i = 0; i < audioBuffer.length; i++) {
                    for (let c = 0; c < numberOfChannels; c++) {
                        const sample = Math.max(-1, Math.min(1, channels[c][i]));
                        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
                        offset += 2;
                    }
                }
                return new Blob([buffer], { type: 'audio/wav' });
            };

            const cutAudioSegment = async (mode) => {
                const { start, end, duration } = normalizeTrimValues();
                if (!duration) throw new Error('Carga primero el audio');
                if ((end - start) < 0.05) throw new Error('Selecciona un tramo más amplio');

                const localCtx = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await readBlobAsArrayBuffer(workingBlob);
                const decoded = await localCtx.decodeAudioData(arrayBuffer.slice(0));
                const sr = decoded.sampleRate;
                const from = Math.floor(start * sr);
                const to = Math.floor(end * sr);

                let outputLength = 0;
                if (mode === 'keep-only') outputLength = Math.max(1, to - from);
                else outputLength = Math.max(1, decoded.length - (to - from));

                const out = localCtx.createBuffer(decoded.numberOfChannels, outputLength, sr);

                for (let c = 0; c < decoded.numberOfChannels; c++) {
                    const source = decoded.getChannelData(c);
                    const target = out.getChannelData(c);
                    if (mode === 'keep-only') {
                        target.set(source.subarray(from, to), 0);
                    } else {
                        target.set(source.subarray(0, from), 0);
                        target.set(source.subarray(to), from);
                    }
                }

                localCtx.close();
                return encodeWav(out);
            };

            controls.addEventListener('input', (event) => {
                const input = event.target;
                if (!(input instanceof HTMLInputElement)) return;
                const value = Number(input.value);
                if (input.dataset.audio === 'gain' && gainNode) gainNode.gain.value = value;
                if (input.dataset.audio === 'rate') baseRate = value;
                if (input.dataset.audio === 'detune') {
                    detuneCents = value;
                    player.preservesPitch = false;
                }
                player.playbackRate = baseRate * Math.pow(2, detuneCents / 1200);
            });

            trimControls.addEventListener('input', (event) => {
                const input = event.target;
                if (!(input instanceof HTMLInputElement)) return;
                const duration = Number.isFinite(player.duration) ? player.duration : 0;
                if (!duration) return;
                if (input.dataset.audioTrim === 'start-range') trimStartInput.value = ((Number(input.value) / 100) * duration).toFixed(2);
                if (input.dataset.audioTrim === 'end-range') trimEndInput.value = ((Number(input.value) / 100) * duration).toFixed(2);
                normalizeTrimValues();
            });

            trimControls.querySelectorAll('input[type="number"]').forEach(inp => inp.addEventListener('change', normalizeTrimValues));

            player.addEventListener('loadedmetadata', syncTrimFromDuration);
            player.addEventListener('timeupdate', () => {
                if (!trimLoop) return;
                if (player.currentTime >= trimLoop.end) player.currentTime = trimLoop.start;
            });
            player.addEventListener('seeked', () => {
                if (!trimLoop) return;
                if (player.currentTime < trimLoop.start || player.currentTime > trimLoop.end) player.currentTime = trimLoop.start;
            });

            actions.addEventListener('click', async (event) => {
                const btn = event.target.closest('button[data-audio-action]');
                if (!btn) return;
                const action = btn.dataset.audioAction;
                if (action === 'enable') {
                    try {
                        ensureAudioGraph();
                        await audioCtx.resume();
                        UIManager.showToast('Efectos de audio activados');
                    } catch (e) {
                        UIManager.showToast('No se pudo activar audio: ' + e.message, true);
                    }
                }

                if (action === 'preview-trim') {
                    const { start, end } = normalizeTrimValues();
                    if (end <= start) {
                        UIManager.showToast('Rango inválido', true);
                        return;
                    }
                    trimLoop = { start, end };
                    player.currentTime = start;
                    player.play().catch(() => {});
                    UIManager.showToast(`Previsualizando ${start.toFixed(1)}s a ${end.toFixed(1)}s`);
                }

                if (action === 'cut-out' || action === 'keep-only') {
                    try {
                        const mode = action === 'cut-out' ? 'remove-range' : 'keep-only';
                        const processed = await cutAudioSegment(mode);
                        workingBlob = processed;
                        setPlayerBlob(workingBlob);
                        trimLoop = null;
                        player.addEventListener('loadedmetadata', () => {
                            trimStartInput.value = '0';
                            trimEndInput.value = '0';
                            syncTrimFromDuration();
                            normalizeTrimValues();
                        }, { once: true });
                        UIManager.showToast(action === 'cut-out' ? 'Trozo eliminado' : 'Trozo conservado');
                    } catch (e) {
                        UIManager.showToast(`No se pudo editar el audio: ${e.message}`, true);
                    }
                }

                if (action === 'download') {
                    const url = URL.createObjectURL(workingBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    const extOut = workingBlob.type === 'audio/wav' ? 'wav' : ext;
                    a.download = `edited_${file.name.replace(/\.[^.]+$/, '')}.${extOut}`;
                    a.click();
                    setTimeout(() => URL.revokeObjectURL(url), 1200);
                }
            });

            shell.append(player, controls, trimControls, actions);
            container.appendChild(shell);
            return container;
        }

        static async exportPdfWithAnnotations(file, container) {
            UIManager.showToast('Generando PDF...'); await PluginLoader.load('pdflib');
            const { PDFDocument, rgb, StandardFonts } = window.PDFLib;
            try {
                const pdfDoc = await PDFDocument.load(await file.blob.arrayBuffer());
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
                const wrappers = container.querySelectorAll('.pdf-page-wrapper');
                pdfDoc.getPages().forEach(async (page, i) => {
                    if (!wrappers[i]) return;
                    const { height } = page.getSize(); const scale = 1.2;
                    wrappers[i].querySelectorAll('.pdf-text-input').forEach(inp => {
                        const txt = inp.innerText.trim();
                        if (txt) page.drawText(txt, { x: parseFloat(inp.style.left)/scale, y: height - (parseFloat(inp.style.top)/scale) - 14, size: 14, font, color: rgb(0,0,0) });
                    });
                    const cvs = wrappers[i].querySelector('.pdf-canvas-layer');
                    if (cvs && cvs.toDataURL().length > 1000) page.drawImage(await pdfDoc.embedPng(cvs.toDataURL()), { x:0, y:0, width: page.getWidth(), height: page.getHeight() });
                });
                const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([await pdfDoc.save()], {type: 'application/pdf'})); a.download = `edited_${file.name}`; a.click();
            } catch (e) { console.error(e); }
        }

        static async createHtmlView(file) {
            await this.loadMonaco();
            const wrapper = document.createElement('div'); wrapper.style.height = '100%'; wrapper.style.display = 'flex'; wrapper.style.flexDirection = 'column';
            const tb = document.createElement('div'); tb.style.cssText = 'padding:5px 10px;background:var(--bg-header);border-bottom:1px solid var(--border);display:flex;gap:10px;';
            const run = document.createElement('button'); run.innerHTML = '<i class="fa-solid fa-play" style="color:var(--success)"></i> Actualizar'; run.style.cssText = 'background:none;border:none;color:var(--text-primary);cursor:pointer;font-weight:bold;';
            const tog = document.createElement('button'); tog.innerHTML = '<i class="fa-solid fa-eye"></i> Alternar'; tog.style.cssText = 'background:none;border:none;color:var(--text-secondary);cursor:pointer;';
            tb.append(run, tog); wrapper.append(tb);

            const ctr = document.createElement('div'); ctr.className = 'split-view';
            const ed = document.createElement('div'); ed.className = 'split-editor';
            const res = document.createElement('div'); res.className = 'split-resizer-handle';
            const pre = document.createElement('div'); pre.className = 'split-preview'; pre.style.padding = '0'; pre.style.background = '#fff';
            const ifr = document.createElement('iframe'); ifr.style.cssText = 'width:100%;height:100%;border:none;';
            pre.appendChild(ifr); ctr.append(ed, res, pre); wrapper.appendChild(ctr);

            // Use contentRef if available for text/code files
            const initialContent = file.contentRef || await file.blob.text();

            const editor = monaco.editor.create(ed, {
                value: initialContent, language: 'html', theme: 'vs-dark', automaticLayout: false, fontFamily: 'var(--font-code)', letterSpacing: 0
            });
            const layout = () => requestAnimationFrame(() => editor.layout());
            new ResizeObserver(layout).observe(ed);
            
            let drag = false;
            res.onmousedown = () => { drag = true; pre.style.pointerEvents = 'none'; };
            document.onmousemove = e => { if(drag) { ed.style.width = (e.clientX / ctr.offsetWidth * 100) + '%'; layout(); } };
            document.onmouseup = () => { drag = false; pre.style.pointerEvents = 'auto'; };

            tog.onclick = () => { pre.classList.toggle('hidden-pane'); res.classList.toggle('hidden-pane'); ed.classList.toggle('full-width'); layout(); };
            run.onclick = () => { const d = ifr.contentDocument; d.open(); d.write(editor.getValue()); d.close(); };
            editor.onDidChangeModelContent(() => { file.isDirty = true; file.contentRef = editor.getValue(); App.instance.renderTabs(); });
            
            setTimeout(() => run.click(), 500);
            return wrapper;
        }

        static async createMarkdownView(file) {
            await this.loadMonaco(); await PluginLoader.load('marked');
            
            const wrapper = document.createElement('div'); wrapper.style.height = '100%'; wrapper.style.display = 'flex'; wrapper.style.flexDirection = 'column';
            const tb = document.createElement('div'); tb.style.cssText = 'padding:5px 10px;background:var(--bg-header);border-bottom:1px solid var(--border);display:flex;gap:10px;justify-content:flex-end;';
            const tog = document.createElement('button'); tog.innerHTML = '<i class="fa-solid fa-eye"></i> Alternar Vista'; tog.style.cssText = 'background:none;border:none;color:var(--text-secondary);cursor:pointer;';
            tb.appendChild(tog); wrapper.appendChild(tb);

            const ctr = document.createElement('div'); ctr.className = 'split-view';
            const ed = document.createElement('div'); ed.className = 'split-editor';
            const res = document.createElement('div'); res.className = 'split-resizer-handle';
            const pre = document.createElement('div'); pre.className = 'split-preview';
            ctr.append(ed, res, pre); wrapper.appendChild(ctr);

            const initialContent = file.contentRef || await file.blob.text();

            const editor = monaco.editor.create(ed, {
                value: initialContent, language: 'markdown', theme: 'vs-dark', automaticLayout: false, fontFamily: 'var(--font-code)', wordWrap: 'on', letterSpacing: 0
            });
            
            const layout = () => requestAnimationFrame(() => editor.layout());
            new ResizeObserver(layout).observe(ed);
            
            let drag = false;
            res.onmousedown = () => { drag = true; };
            document.onmousemove = e => { if(drag) { ed.style.width = (e.clientX / ctr.offsetWidth * 100) + '%'; layout(); } };
            document.onmouseup = () => { drag = false; };

            tog.onclick = () => { pre.classList.toggle('hidden-pane'); res.classList.toggle('hidden-pane'); ed.classList.toggle('full-width'); layout(); };

            const update = () => { 
                const val = editor.getValue();
                if (window.marked && window.marked.parse) {
                    try {
                        pre.innerHTML = window.marked.parse(val);
                        if(window.renderMathInElement) window.renderMathInElement(pre);
                    } catch(err) { pre.innerHTML = `<div style="color:red">Error renderizando Markdown: ${err.message}</div>`; }
                } else if (window.marked) { pre.innerHTML = window.marked(val); } else { pre.innerHTML = "<div>Cargando motor de renderizado...</div>"; }
                file.isDirty = true; file.contentRef = val; App.instance.renderTabs(); 
            };
            
            editor.onDidChangeModelContent(update); 
            setTimeout(update, 200);
            editor.onDidScrollChange(e => { if(e.scrollTopChanged) pre.scrollTop = (e.scrollTop / (e.scrollHeight - e.viewHeight)) * (pre.scrollHeight - pre.clientHeight); });
            
            return wrapper;
        }

        static async createCodeView(file, ext) {
            await this.loadMonaco();
            const ctr = document.createElement('div'); ctr.style.height = '100%'; ctr.style.display='flex'; ctr.style.flexDirection='column';
            const tb = document.createElement('div'); tb.style.cssText = 'padding:5px 10px;background:var(--bg-header);border-bottom:1px solid var(--border);';
            const run = document.createElement('button'); run.innerHTML = '<i class="fa-solid fa-play" style="color:var(--success)"></i> Run'; run.style.cssText = 'background:none;border:none;color:var(--text-primary);cursor:pointer;font-weight:bold;';
            tb.appendChild(run); ctr.appendChild(tb);

            const edDiv = document.createElement('div'); edDiv.style.cssText = 'flex:1;overflow:hidden;';
            const cons = document.createElement('div'); cons.className = 'console-panel'; cons.style.display = 'none';
            ctr.append(edDiv, cons);

            const initialContent = file.contentRef || await file.blob.text();

            const editor = monaco.editor.create(edDiv, {
                value: initialContent, language: this.mapLang(ext), theme: 'vs-dark', automaticLayout: false, fontFamily: 'var(--font-code)', letterSpacing: 0
            });
            App.instance.currentEditor = editor;
            new ResizeObserver(() => requestAnimationFrame(() => editor.layout())).observe(edDiv);
            editor.onDidChangeModelContent(() => { file.isDirty = true; file.contentRef = editor.getValue(); App.instance.renderTabs(); });

            run.onclick = async () => {
                const code = editor.getValue();
                cons.style.display = 'block'; cons.innerHTML = '<div style="color:gray">// Ejecutando...</div>';
                const log = (msg, type='log') => { const d = document.createElement('div'); d.className = `log-entry ${type==='error'?'log-error':(type==='success'?'log-success':'log-info')}`; d.textContent = msg; cons.appendChild(d); cons.scrollTop = cons.scrollHeight; };

                if (ext === 'js') {
                    try {
                        const originalLog = console.log;
                        console.log = (...args) => { originalLog(...args); log(args.join(' ')); };
                        eval(code); 
                        console.log = originalLog;
                        log('Ejecución JS finalizada.', 'success');
                    } catch(e) { log(e.message, 'error'); }
                } 
                else if (ext === 'py' || ext === 'java' || ext === 'cpp') {
                    log(`Compilando ${ext} en la nube (Piston API)...`, 'info');
                    const result = await CompilerService.execute(ext, code);
                    if (result.stdout) log(result.stdout);
                    if (result.stderr) log(result.stderr, 'error');
                    if (result.requiresRunnerSetup) UIManager.showRunnerSetupModal();
                    const exitCode = Number.isInteger(result.code) ? result.code : (result.stderr ? 1 : 0);
                    log(`Ejecución ${ext} finalizada. Exit code: ${exitCode}`, exitCode === 0 ? 'success' : 'error');
                }
                else { log('Ejecución no soportada para este lenguaje.', 'error'); }
            };
            return ctr;
        }

        static async createPdfView(file) {
            const ctr = document.createElement('div');
            ctr.className = 'content-scroll';
            ctr.id = 'pdf-container';
            ctr.style.cssText = 'background:var(--bg-panel);padding:16px;height:100%;';

            const hint = document.createElement('div');
            hint.style.cssText = 'margin-bottom:12px;color:var(--text-secondary);font-size:13px;';
            hint.innerHTML = '<i class="fa-solid fa-file-pdf"></i> Vista previa del PDF.';

            const frame = document.createElement('iframe');
            frame.style.cssText = 'width:100%;height:calc(100% - 30px);border:1px solid var(--border);border-radius:8px;background:#fff;';
            frame.src = URL.createObjectURL(file.blob);
            frame.title = `Editor PDF - ${file.name}`;

            App.instance.currentEditor = null; // No Monaco in PDF view
            ctr.append(hint, frame);
            return ctr;
        }

        static async createHexView(file) {
            App.instance.currentEditor = null;
            const div = document.createElement('div'); div.className = 'hex-view';
            div.innerHTML = `<div class="hex-header">OFFSET</div><div class="hex-header">BYTES</div><div class="hex-header">ASCII</div>`;
            return div; 
        }
    }

    class UIManager {
        static showToast(msg) { const t = document.createElement('div'); t.style.cssText = 'position:fixed;bottom:20px;right:20px;background:var(--accent);color:white;padding:10px 20px;border-radius:5px;z-index:1000;'; t.textContent = msg; document.body.appendChild(t); setTimeout(() => t.remove(), 3000); }
        
        static toggleCommandPalette() { 
            const el = document.getElementById('cmd-backdrop');
            const isVisible = el.style.display === 'flex';
            el.style.display = isVisible ? 'none' : 'flex';
            if (!isVisible) {
                document.getElementById('cmd-input').value = '';
                document.getElementById('cmd-input').focus();
                this.renderCommands();
            }
        }
        
        static closeModal() { document.getElementById('generic-modal').style.display = 'none'; }
        static showModal(title, contentNode) { document.getElementById('generic-modal-title').textContent = title; const body = document.getElementById('generic-modal-body'); body.innerHTML = ''; body.appendChild(contentNode); document.getElementById('generic-modal').style.display = 'flex'; }
        static showRunnerSetupModal() {
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.gap = '12px';

            const text = document.createElement('div');
            text.style.color = 'var(--text-secondary)';
            text.innerHTML = 'La API pública de <strong>emkc.org</strong> ahora requiere whitelist. Configura tu propio endpoint de Piston para volver a ejecutar código.';

            const actions = document.createElement('div');
            actions.style.display = 'flex';
            actions.style.gap = '8px';

            const openSettingsBtn = document.createElement('button');
            openSettingsBtn.textContent = 'Abrir Ajustes';
            openSettingsBtn.style.cssText = 'padding:10px 12px;background:var(--accent);color:white;border:none;border-radius:8px;cursor:pointer;';
            openSettingsBtn.onclick = () => {
                this.closeModal();
                SettingsManager.open();
                const endpointInput = document.getElementById('runner-endpoint-input');
                if (endpointInput) endpointInput.focus();
            };

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Cerrar';
            closeBtn.style.cssText = 'padding:10px 12px;background:transparent;color:var(--text-secondary);border:1px solid var(--border);border-radius:8px;cursor:pointer;';
            closeBtn.onclick = () => this.closeModal();

            actions.append(openSettingsBtn, closeBtn);
            container.append(text, actions);
            this.showModal('Configura endpoint de ejecución', container);
        }
        
        static selectDraftType() { 
            return new Promise((resolve) => { 
                const container = document.createElement('div'); 
                container.className = 'draft-grid'; 
                const types = [
                    { id: 'md', label: 'Markdown', icon: 'fa-file-lines', color: '#3b82f6' }, 
                    { id: 'txt', label: 'Texto plano', icon: 'fa-file-lines', color: '#94a3b8' },
                    { id: 'html', label: 'HTML', icon: 'fa-html5', color: '#e34f26' }, 
                    { id: 'js', label: 'JavaScript', icon: 'fa-js', color: '#f7df1e' }, 
                    { id: 'py', label: 'Python', icon: 'fa-python', color: '#3776ab' },
                    { id: 'java', label: 'Java', icon: 'fa-java', color: '#f89820' }
                ]; 
                types.forEach(t => { 
                    const btn = document.createElement('div'); 
                    btn.className = 'draft-option'; 
                    btn.innerHTML = `<i class="fa-brands ${t.icon}" style="color:${t.color}"></i><span>${t.label}</span>`; 
                    btn.onclick = () => { this.closeModal(); resolve(t.id); }; 
                    container.appendChild(btn); 
                }); 
                this.showModal('Crear Nuevo Archivo', container); 
            }); 
        }
        
        static showShortcutsHelp() {
            const shortcuts = {
                'General': [
                    { key: 'Ctrl + K', desc: 'Abrir Paleta de Comandos' },
                    { key: 'Ctrl + O', desc: 'Abrir Archivo' },
                    { key: 'Ctrl + S', desc: 'Guardar Archivo' },
                    { key: 'Ctrl + Rueda', desc: 'Zoom Interfaz/Editor' }
                ],
                'Editor de Código': [
                    { key: 'Ctrl + F', desc: 'Buscar texto' },
                    { key: 'Alt + Click', desc: 'Multi-cursor' },
                    { key: 'Ctrl + /', desc: 'Comentar línea' }
                ],
                'Gestión': [
                    { key: 'Esc', desc: 'Cerrar Modales' }
                ]
            };
            
            const container = document.createElement('div');
            container.className = 'shortcuts-container';
            Object.entries(shortcuts).forEach(([section, items]) => {
                const secDiv = document.createElement('div'); secDiv.className = 'shortcut-section';
                secDiv.innerHTML = `<h3>${section}</h3>`;
                const list = document.createElement('div'); list.className = 'shortcut-list';
                items.forEach(item => {
                    const row = document.createElement('div'); row.className = 'shortcut-row';
                    const keysHtml = item.key.split('+').map(k => `<kbd>${k.trim()}</kbd>`).join(' + ');
                    row.innerHTML = `<span class="shortcut-desc">${item.desc}</span> <span class="shortcut-keys">${keysHtml}</span>`;
                    list.appendChild(row);
                });
                secDiv.appendChild(list); container.appendChild(secDiv);
            });
            this.showModal('Atajos de Teclado', container);
        }

        // --- NEW: Export Format Selector ---
        static showExportOptions() {
            return new Promise((resolve) => {
                const container = document.createElement('div');
                container.className = 'draft-grid';
                const opts = [
                    { id: 'pdf', label: 'PDF (Visual)', icon: 'fa-file-pdf', color: '#e11d48' },
                    { id: 'html', label: 'HTML (Word)', icon: 'fa-file-word', color: '#2563eb' },
                    { id: 'src', label: 'Código Fuente', icon: 'fa-code', color: '#10b981' },
                    { id: 'raw', label: 'Original', icon: 'fa-file', color: '#64748b' }
                ];
                opts.forEach(t => {
                    const btn = document.createElement('div');
                    btn.className = 'draft-option';
                    btn.innerHTML = `<i class="fa-solid ${t.icon}" style="color:${t.color}"></i><span>${t.label}</span>`;
                    btn.onclick = () => { this.closeModal(); resolve(t.id); };
                    container.appendChild(btn);
                });
                this.showModal('Exportar Como', container);
            });
        }

        static renderCommands() { 
            const list = document.getElementById('cmd-list'); list.innerHTML = '';
            const cmds = App.instance.generateCommandsList();
            cmds.forEach(cmd => {
                const li = document.createElement('li'); li.className = 'cmd-item';
                li.innerHTML = `<div style="display:flex; align-items:center; gap:10px;"><i class="fa-solid ${cmd.icon}" style="width:20px;"></i> ${cmd.label}</div>`;
                li.onclick = () => { this.toggleCommandPalette(); cmd.action(); };
                list.appendChild(li);
            });
        }
    }

    class App {
        constructor() { this.openTabs = []; this.activeTab = null; this.currentEditor = null; this.bindEvents(); this.restoreSession(); SettingsManager.loadDefaults(); }
        static get instance() { if(!window.__app) window.__app = new App(); return window.__app; }
        
        bindEvents() { 
            document.getElementById('file-input').onchange = e => this.handleFiles(Array.from(e.target.files)); 
            window.addEventListener('keydown', (e) => {
                if((e.ctrlKey || e.metaKey) && e.key === 'k') { e.preventDefault(); UIManager.toggleCommandPalette(); }
            });
            document.getElementById('cmd-backdrop').onclick = e => { if(e.target.id === 'cmd-backdrop') e.target.style.display = 'none'; };
            window.addEventListener('wheel', (e) => {
                if(e.ctrlKey) { e.preventDefault(); if (this.currentEditor) { const currentFont = this.currentEditor.getOption(monaco.editor.EditorOption.fontSize); const newFont = e.deltaY > 0 ? currentFont - 1 : currentFont + 1; if(newFont >= 8 && newFont <= 72) { this.currentEditor.updateOptions({ fontSize: newFont }); const ind = document.getElementById('zoom-float'); ind.textContent = `${newFont}px`; ind.classList.add('visible'); clearTimeout(this.zoomTimer); this.zoomTimer = setTimeout(() => ind.classList.remove('visible'), 1000); } } }
            }, {passive: false});
        }
        
        openFileDialog() { document.getElementById('file-input').click(); }
        async handleFiles(files) { for(const f of files) { const meta = { id: crypto.randomUUID(), name: f.name, blob: f, isDirty: false }; await FileSystem.put(meta); this.openTabs.push(meta); this.activateTab(meta.id); } this.saveSession(); }
        
        async createDraft() { 
            const type = await UIManager.selectDraftType(); 
            if(!type) return; 
            let content, name, mime; 
            const ts = Date.now(); 
            switch(type) { 
                case 'html': 
                    content = `<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Demo Interactiva</title>
  <style>
    body { margin: 0; height: 100vh; display: flex; justify-content: center; align-items: center; background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); color: white; font-family: 'Segoe UI', sans-serif; }
    .card { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(12px); padding: 2rem; border-radius: 1rem; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); max-width: 400px; animation: float 6s ease-in-out infinite; }
    h1 { background: linear-gradient(to right, #818cf8, #c084fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin: 0 0 1rem 0; }
    button { background: #6366f1; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: bold; cursor: pointer; transition: all 0.2s; margin-top: 1rem; }
    button:hover { background: #4f46e5; transform: scale(1.05); }
    @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
  </style>
</head>
<body>
  <div class="card">
    <h1>¡Hola Hacker!</h1>
    <p>Este es un ejemplo de HTML + CSS con efecto de vidrio esmerilado (Glassmorphism).</p>
    <button onclick="saludar()">Haz Clic Aquí</button>
  </div>
  <script>
    function saludar() {
      const btn = document.querySelector('button');
      btn.innerText = '¡Funciona! 🚀';
      if(window.confetti) confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
      else alert('¡Funciona!');
    }
  <\/script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"><\/script>
</body>
</html>`;
                    name = `index_${ts}.html`; mime = 'text/html'; break; 
                case 'js': content = '// JavaScript\nconsole.log("Hola Mundo");'; name = `script_${ts}.js`; mime = 'text/javascript'; break; 
                case 'py': content = '# Python\nprint("Hola Mundo")'; name = `main_${ts}.py`; mime = 'text/x-python'; break; 
                case 'java': content = 'public class Main {\n    public static void main(String[] args) {\n        System.out.println("Hola Mundo desde Java");\n    }\n}'; name = `Main_${ts}.java`; mime = 'text/x-java-source'; break;
                case 'txt': content = 'Escribe aquí tu texto...'; name = `nota_${ts}.txt`; mime = 'text/plain'; break;
                default: 
                    content = `# 🚀 Bienvenido a GentleDoc

Este es un ejemplo avanzado de **Markdown** con soporte en tiempo real.

## Características
- **Sintaxis GFM**: GitHub Flavored Markdown.
- **Matemáticas**: Soporte para KaTeX.
- **Código**: Resaltado de sintaxis.

### Matemáticas
La fórmula cuadrática es:
$$ x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$

### Código
\`\`\`javascript
function saludar() {
  console.log("Hola Mundo!");
}
\`\`\`

### Tabla
| Item | Cantidad | Precio |
|------|:--------:|-------:|
| CPU  | 1        | $300   |
| RAM  | 2        | $150   |

> "El código es poesía lógica."
`;
                    name = `draft_${ts}.md`; mime = 'text/markdown'; 
            } 
            const blob = new Blob([content], {type: mime}); 
            const meta = { id: crypto.randomUUID(), name, blob, isDirty: false }; 
            await FileSystem.put(meta); this.openTabs.push(meta); this.activateTab(meta.id); this.saveSession(); 
        }
        
        async activateTab(id) {
            this.activeTab = this.openTabs.find(t => t.id === id);
            if (!this.activeTab) return; 

            this.renderTabs();
            
            const welcomeMsg = document.getElementById('welcome-msg');
            if(welcomeMsg) welcomeMsg.classList.add('hidden');
            
            const ctr = document.getElementById('content-scroll');
            // Safe clear
            if(ctr) {
                ctr.innerHTML = '';
                try {
                    const viewer = await EditorFactory.createViewer(this.activeTab);
                    ctr.appendChild(viewer);
                } catch (e) {
                    console.error("Error creating viewer:", e);
                    ctr.textContent = "Error al cargar el visor.";
                }
            }
            
            const statusText = document.getElementById('status-text');
            if(statusText) statusText.textContent = `Editando: ${this.activeTab.name}`;
            
            const statusMeta = document.getElementById('status-meta');
            if(statusMeta) statusMeta.textContent = `${(this.activeTab.blob.size / 1024).toFixed(1)} KB`;
        }

        renderTabs() {
            const c = document.getElementById('tabs');
            c.innerHTML = '';
            this.openTabs.forEach(t => {
                const el = document.createElement('div');
                el.className = `tab ${this.activeTab?.id === t.id ? 'active' : ''}`;

                const name = document.createElement('span');
                name.className = 'tab-name';
                name.textContent = `${t.isDirty ? '● ' : ''}${t.name}`;

                const close = document.createElement('span');
                close.className = 'close';
                close.textContent = '×';

                el.appendChild(name);
                el.appendChild(close);
                el.onclick = () => this.activateTab(t.id);
                close.onclick = e => { e.stopPropagation(); this.closeTab(t.id); };
                c.appendChild(el);
            });
        }
        closeTab(id) { this.openTabs = this.openTabs.filter(t => t.id !== id); if(this.activeTab?.id === id) { this.activeTab = this.openTabs[0] || null; if(this.activeTab) this.activateTab(this.activeTab.id); else { document.getElementById('content-scroll').innerHTML = ''; document.getElementById('welcome-msg').classList.remove('hidden'); this.updateRecents(); } } this.renderTabs(); this.saveSession(); }
        
        async updateRecents() { const files = await FileSystem.getAll(); const list = document.getElementById('welcome-recents-list'); list.innerHTML = ''; files.slice(-5).reverse().forEach(f => { const div = document.createElement('div'); div.className = 'welcome-recent-item'; div.innerHTML = `<span><i class="fa-solid fa-file"></i> ${f.name}</span> <span style="font-size:11px;color:gray">${(f.blob.size/1024).toFixed(1)} KB</span>`; div.onclick = () => { if(!this.openTabs.find(t=>t.id===f.id)) this.openTabs.push(f); this.activateTab(f.id); }; list.appendChild(div); }); }
        saveSession() { localStorage.setItem('hacker_session_v2', JSON.stringify(this.openTabs.map(t => t.id))); }
        
        async restoreSession() {
            await this.updateRecents();
            const sessionIds = JSON.parse(localStorage.getItem('hacker_session_v2') || '[]');
            if (sessionIds.length > 0) {
                for (const id of sessionIds) {
                    const file = await FileSystem.getFile(id);
                    if (file) this.openTabs.push(file);
                }
                if (this.openTabs.length > 0) {
                    this.activateTab(this.openTabs[0].id);
                }
            }
        }
        
        toggleTheme() { document.documentElement.setAttribute('data-theme', document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light'); }
        
        // --- FIXED SAVE LOGIC FOR PWA PERSISTENCE ---
        async saveCurrent() { 
            if(this.activeTab) { 
                if(this.activeTab.contentRef) { 
                    // Update the BLOB if it's a text-based format for download accuracy
                    const ext = this.activeTab.name.split('.').pop().toLowerCase();
                    const textFormats = ['md', 'html', 'js', 'py', 'txt', 'css', 'json', 'java', 'cpp'];
                    
                    if (textFormats.includes(ext)) {
                        this.activeTab.blob = new Blob([this.activeTab.contentRef], {type: this.activeTab.blob.type});
                    }
                    // For binary formats (ODT/DOCX), we keep contentRef separate for editor state
                    // and do NOT overwrite the original blob to allow "revert" or specialized export.
                    
                    this.activeTab.isDirty = false; 
                    await FileSystem.put(this.activeTab); // Store to IndexedDB
                    this.renderTabs(); 
                    UIManager.showToast('Guardado en navegador'); 
                } 
            } 
        }
        
        async exportCurrent() { this.promptExport(); } // Alias for button

        generateCommandsList() {
            const cmds = [
                { id: 'shortcuts', label: 'Ver Atajos de Teclado', icon: 'fa-keyboard', action: () => UIManager.showShortcutsHelp() },
                { id: 'open', label: 'Abrir archivo local', icon: 'fa-folder-open', action: () => this.openFileDialog() },
                { id: 'draft', label: 'Nuevo Borrador', icon: 'fa-plus', action: () => this.createDraft() },
                { id: 'theme', label: 'Cambiar Tema (Toggle)', icon: 'fa-circle-half-stroke', action: () => this.toggleTheme() },
                { id: 'full', label: 'Modo Pantalla Completa', icon: 'fa-expand', action: () => document.documentElement.requestFullscreen() },
            ];

            if(this.activeTab) {
                cmds.push(
                    { id: 'save', label: 'Guardar Archivo', icon: 'fa-floppy-disk', action: () => this.saveCurrent() },
                    { id: 'export', label: 'Exportar Archivo', icon: 'fa-file-export', action: () => this.promptExport() },
                    { id: 'close', label: 'Cerrar Pestaña', icon: 'fa-xmark', action: () => this.closeTab(this.activeTab.id) }
                );
            }
            return cmds;
        }
    }

    window.App = App; window.UIManager = UIManager; window.SettingsManager = SettingsManager;
  </script>
</body>
</html>
